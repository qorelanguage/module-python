#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires python
%requires QUnit

%exec-class PythonTest

class PythonTest inherits Test {
    public {
        const ExprTests = (
            {"expr": "1 + 1", "val": 2},
            {"expr": "1.1", "val": 1.1},
            {"expr": "True", "val": True},
            {"expr": "False", "val": False},
            {"expr": "'str'", "val": "str"},
            {"expr": "bytes.fromhex('abcd')", "val": <abcd>},
            {"expr": "bytearray.fromhex('abcd')", "val": <abcd>},
            {"expr": "{'a': 1}", "val": {"a": 1}},
            {"expr": "(1).bit_length()", "val": 1},
        );

        const Values = (
            1,
            1.1,
            True,
            False,
            "str",
            <abcd>,
            {"a": 1},
            (1, 2, 3),
        );
    }

    constructor() : Test("python test", "1.0") {
        addTestCase("basic test", \basicTest());
        # Set return value for compatibility with test harnesses that check the return value
        set_return_value(main());
    }

    basicTest() {
        {
            PythonProgram p("def test(val):\n    return val", "value test container");
            foreach hash<auto> info in (ExprTests) {
                assertEq(info.val, PythonProgram::evalExpression(info.expr), "static: " + info.expr);
                assertEq(info.val, p.evalExpression(info.expr), info.expr);
            }
            map assertEq($1, p.callFunction("test", $1), sprintf("value %d/%d", $# + 1, Values.size())), Values;
        }

        {
            PythonProgram pp("def test():\n    return 1", "test.py");
            assertEq(1, pp.callFunction("test"));
            assertThrows("NO-FUNCTION", \pp.callFunction(), "xxx");
            # test module dictionary key that exists but is not a function
            assertThrows("NO-FUNCTION", \pp.callFunction(), "__name__");
        }

        {
            PythonProgram pp("def test(val):\n    return val + 1", "test.py");
            assertEq(2, pp.callFunction("test", 1));
        }

        # test parse error handling
        assertThrows("SyntaxError", "invalid syntax",
            sub () { PythonProgram pp("def test(int val):\n    return val + 1", "test.py"); });

        {
            PythonProgram pp("def test(val):\n    return val + 1", "test.py");
            assertThrows("TypeError", \pp.callFunction(), ("test", 1, 2));
        }

        {
            PythonProgram pp("def test():\n    raise Exception('err', 'desc')", "test.py");
            assertThrows("Exception", \pp.callFunction(), "test");
        }

        {
            PythonProgram pp("import datetime\ndef test():\n    return datetime.datetime.now()", "test.py");
            auto val = pp.callFunction("test");
            auto control = now_us();
            assertEq(Type::Date, val.type());
            assertLt(1m, control - val);
        }

        {
            PythonProgram pp("def test(dict, key):\n    return dict.get(key)", "test.py");
            assertEq(1, pp.callFunction("test", {"a": 1}, "a"));
            date dt = now_us();
            assertEq(dt, pp.callFunction("test", {"a": dt}, "a"));
            dt = 2s;
            assertEq(dt, pp.callFunction("test", {"a": dt}, "a"));
            binary b = <abcd>;
            assertEq(b, pp.callFunction("test", {"a": b}, "a"));
            list<auto> l = (1, "two", 3.0);
            assertEq(l, pp.callFunction("test", {"a": l}, "a"));
            assertEq(1.1, pp.callFunction("test", {"a": 1.1}, "a"));
        }

        {
            PythonProgram pp("import datetime\ndef test():\n    return datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=1)))", "test.py");
            auto val = pp.callFunction("test");
            auto control = now_us();
            assertEq(Type::Date, val.type());
            assertLt(1m, control - val);
            assertEq(3600, val.info().utc_secs_east);
        }

        {
            PythonProgram pp("class test:
    def normal(self, val):
        return val + base

    @staticmethod
    def test(val):
        return val + test.base

    base = 1
", "test.py");
            assertEq(2, pp.callMethod("test", "test", 1));
            assertEq(1, pp.callMethod("int", "bit_length", 1));

            assertThrows("NO-METHOD", \pp.callMethod(), ("test", "xxx"));
            assertThrows("NameError", \pp.callMethod(), ("test", "normal", NOTHING, 1));
            assertThrows("NO-METHOD", \pp.callMethod(), ("test", "__name__"));
        }
    }
}