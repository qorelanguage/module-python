#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%require-types
%strict-args
%enable-all-warnings
%no-child-restrictions

%requires python
%requires QUnit
%requires reflection
%try-module json
%define NO_JSON
%endtry

%exec-class PythonTest

class PythonTest inherits Test {
    public {
        const ExprTests = (
            {"expr": "1 + 1", "val": 2},
            {"expr": "1.1", "val": 1.1},
            {"expr": "True", "val": True},
            {"expr": "False", "val": False},
            {"expr": "'str'", "val": "str"},
            {"expr": "bytes.fromhex('abcd')", "val": <abcd>},
            {"expr": "bytearray.fromhex('abcd')", "val": <abcd>},
            {"expr": "{'a': 1}", "val": {"a": 1}},
            {"expr": "(1).bit_length()", "val": 1},
        );

        const Values = (
            1,
            1.1,
            True,
            False,
            "str",
            <abcd>,
            {"a": 1},
            (1, 2, 3),
        );
    }

    constructor() : Test("python test", "1.0") {
        addTestCase("python import", \pythonImportTest());
        addTestCase("object lifecycle", \objectLifecycleTest());
        addTestCase("basic test", \basicTest());
        addTestCase("import test", \importTest());
        # Set return value for compatibility with test harnesses that check the return value
        set_return_value(main());
    }

    pythonImportTest() {
        {
            PythonProgram p("", "");
            p.importNamespace("::Test", "x");
            p.evalStatementKeep("
class PyTest(x.TestClass):
    def __init__(self, i):
        super(PyTest, self).__init__(i)

    def pyget(self):
        return self.get()

def test(*args):
    return PyTest(*args)", "test.py");

            object obj = p.callFunction("test", 1);
            assertEq(1, obj.pyget());
            assertEq(1, obj.i);

            # test with no args to base class
            assertThrows("TypeError", \p.callFunction(), "test");
            # test with too many args to Qore base class
            assertThrows("TypeError", \p.callFunction(), ("test", 1, 2));
        }

        {
            PythonProgram p("from qore.__root__ import Test as t
def get():
    return t.get()", "test.py");
            assertEq("55.00 €", p.callFunction("get"));
        }

        {
            Program p(PO_NEW_STYLE);
            p.issueModuleCmd("python", "import-ns Test test");
            p.issueModuleCmd("python", "parse t from test import X");
            assertTrue(True);
        }

        {
            Program p(PO_NEW_STYLE);
            p.issueModuleCmd("python", "import-ns Test test");
            p.issueModuleCmd("python", "parse t from test.X import T");
            assertTrue(True);
        }

        {
            Program p(PO_NEW_STYLE);
            p.issueModuleCmd("python", "import-ns Test test");
            p.issueModuleCmd("python", "alias test.X x");
            p.issueModuleCmd("python", "parse t from x import T");
            assertTrue(True);
        }

        {
            PythonProgram p("
def test1():
    return x.ex1()

def test2():
    return x.ex2()

def z():
    return y.z.exz()
", "test.py");

            p.importNamespace("::Test", "x");

            assertThrows("1", \p.callFunction(), ("test1"));
            assertThrows("TEST", "test", \p.callFunction(), ("test2"));

            p.aliasDefinition("x.ex1", "y.z.exz");
            assertThrows("1", \p.callFunction(), ("z"));

            p.evalStatementKeep("
class PyTest(x.Test):
    def py_test(self):
        return 2
", "new.py");

            p.evalStatementKeep("
def py_test_func(i):
    t = PyTest()
    if (i == 1):
        return t.get()
    return t.py_test()
", "new2.py");

            assertEq(2, p.callFunction("py_test_func", 0));
            assertEq(1, p.callFunction("py_test_func", 1));

            code call_bg = auto sub (string func) {
                Queue q();
                *list<auto> args = argv;
                background (sub () {
                    try {
                        q.push(p.callFunctionArgs(func, args));
                    } catch (hash<ExceptionInfo> ex) {
                        q.push(ex);
                    }
                })();
                return q.get();
            };
            assertEq(2, call_bg("py_test_func", 0));
            assertEq(1, call_bg("py_test_func", 1));

            p.evalStatementKeep("
class PyAbstractTest(x.AbstractTest):
    def __init__(self):
        super(PyAbstractTest, self).__init__()

    def get(self):
        return 3

    def getpy(self):
        return 4
", "new3.py");

            p.evalStatementKeep("
def py_abstract_test(x = 0):
    t = PyAbstractTest()
    if (x):
        return t.getpy()
    return t.get()
", "new4.py");

            assertEq(3, p.callFunction("py_abstract_test"));
            assertEq(4, p.callFunction("py_abstract_test", 1));

            assertEq(3, call_bg("py_abstract_test"));
            assertEq(4, call_bg("py_abstract_test", 1));
        }

        {
            Program p(PO_NEW_STYLE);
            string src = "
class PyTest(x.AbstractTest):
    def get(self):
        return 3

    def getpy(self):
        return 4

    def addonenormal(self, x0):
        return self.addOneNormal(x0)

    def addone(self, x0):
        return x.AbstractTest.addOne(x0)
";
            p.issueModuleCmd("python", "import-ns ::Test x");
            p.issueModuleCmd("python", "parse t " + src);
            p.issueModuleCmd("python", "export-class PyTest");
            Class cls = Class::forName(p, "PyTest");
            object obj = cls.newObject();
            assertEq(3, obj.get());
            assertEq(4, obj.getpy());
            assertEq(5, obj.addonenormal(4));
            assertEq(6, obj.addone(5));

            code call_bg_obj = auto sub (string method) {
                Queue q();
                *list<auto> args = argv;
                background (sub () {
                    try {
                        q.push(call_object_method_args(obj, method, args));
                    } catch (hash<ExceptionInfo> ex) {
                        q.push(ex);
                    }
                })();
                return q.get();
            };

            assertEq(3, call_bg_obj("get"));
            assertEq(4, call_bg_obj("getpy"));
            assertEq(5, call_bg_obj("addonenormal", 4));
            assertEq(6, call_bg_obj("addone", 5));

            p.issueModuleCmd("python", "parse t1 from qore.__root__ import test as t
def dot():
    return t()");
            p.issueModuleCmd("python", "export-func dot");
            p.parse("int sub pydot() { return dot(); }", "pydot");
            assertEq(99, p.callFunction("pydot"));
        }

        {
            Program p(PO_NEW_STYLE);
            p.loadModule("python");
            p.loadModule("reflection");
            p.issueModuleCmd("python", "parse t1 from qore.__root__ import test as t
def dot():
    return t()");
            p.parse("Function sub getfunc(string name) { return Function::forName(name); }", "test");
            p.issueModuleCmd("python", "export-func dot");
            Function f = p.callFunction("getfunc", "dot");
            assertEq(99, f.call());
        }

        {
            Program p(PO_NEW_STYLE);
            p.loadModule("python");
            p.issueModuleCmd("python", "add-module-path " + get_script_dir());
            p.issueModuleCmd("python", "import fib");
            auto x = p.callFunction("fib2", 5);
            assertEq((0, 1, 1, 2, 3), x);
        }
    }

    objectLifecycleTest() {
        PythonProgram p("import qore.xml

class PyXRC(qore.xml.XmlRpcClient):
    def __init__(self, *args):
        super(PyXRC, self).__init__(*args)

def test():
    return qore.xml.XmlRpcClient()

def ctest(*args):
    return PyXRC(*args)", "test.py");
        hash<string, object> object_cache;
        code callback = sub (object obj) {
            # save object in object cache, so it doesn't go out of scope
            object_cache{obj.uniqueHash()} = obj;
        };
        p.setSaveObjectCallback(callback);
        p.callFunction("test");
        #printf("object_cache: %N\n", object_cache);
        assertEq(1, object_cache.size());
        assertEq("XmlRpcClient", object_cache.firstValue().className());

        string url = "http://localhost:8080/";
        object o = p.callFunction("ctest", {"url": url}, True);
        assertEq("PyXRC", o.className());
        assertEq(url, o.getURL());
    }

    basicTest() {
        {
            PythonProgram p("def test(val):\n    return val", "value test container");
            foreach hash<auto> info in (ExprTests) {
                assertEq(info.val, PythonProgram::evalExpression(info.expr), "static: " + info.expr);
                assertEq(info.val, p.evalExpression(info.expr), info.expr);
            }
            map assertEq($1, p.callFunction("test", $1), sprintf("value %d/%d", $# + 1, Values.size())), Values;
        }

        {
            PythonProgram pp("def test():\n    return 1", "test.py");
            assertEq(1, pp.callFunction("test"));
            assertThrows("NO-FUNCTION", \pp.callFunction(), "xxx");
            # test module dictionary key that exists but is not a function
            assertThrows("NO-FUNCTION", \pp.callFunction(), "__name__");

            pp.evalStatementKeep("def test1():\n    return 2", "test1.py");
            assertEq(1, pp.callFunction("test"));
            assertEq(2, pp.callFunction("test1"));

            pp.evalStatementKeep("def test2():\n    return 3", "test2.py");
            assertEq(1, pp.callFunction("test"));
            assertEq(2, pp.callFunction("test1"));
            assertEq(3, pp.callFunction("test2"));
        }

        {
            PythonProgram pp("def test(val):\n    return val + 1", "test.py");
            assertEq(2, pp.callFunction("test", 1));
        }

        # test parse error handling
        assertThrows("SyntaxError", "invalid syntax",
            sub () { PythonProgram pp("def test(int val):\n    return val + 1", "test.py"); });

        {
            PythonProgram pp("def test(val):\n    return val + 1", "test.py");
            assertThrows("TypeError", \pp.callFunction(), ("test", 1, 2));
        }

        {
            PythonProgram pp("def test():\n    raise Exception('err', 'desc')", "test.py");
            assertThrows("Exception", \pp.callFunction(), "test");
        }

        {
            PythonProgram pp("import datetime\ndef test():\n    return datetime.datetime.now()", "test.py");
            auto val = pp.callFunction("test");
            auto control = now_us();
            assertEq(Type::Date, val.type());
            assertLt(1m, control - val);
        }

        {
            PythonProgram pp("def test(dict, key):\n    return dict.get(key)", "test.py");
            assertEq(1, pp.callFunction("test", {"a": 1}, "a"));
            date dt = now_us();
            assertEq(dt, pp.callFunction("test", {"a": dt}, "a"));
            dt = 2s;
            assertEq(dt, pp.callFunction("test", {"a": dt}, "a"));
            binary b = <abcd>;
            assertEq(b, pp.callFunction("test", {"a": b}, "a"));
            list<auto> l = (1, "two", 3.0);
            assertEq(l, pp.callFunction("test", {"a": l}, "a"));
            assertEq(1.1, pp.callFunction("test", {"a": 1.1}, "a"));
        }

        {
            PythonProgram pp("import datetime\ndef test():\n    return datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=1)))", "test.py");
            auto val = pp.callFunction("test");
            auto control = now_us();
            assertEq(Type::Date, val.type());
            assertLt(1m, control - val);
            assertEq(3600, val.info().utc_secs_east);
        }

        {
            PythonProgram pp("
class test:
    def normal(self, val):
        return val + base

    @staticmethod
    def test(val):
        return val + test.base

    @staticmethod
    def do_ex():
        raise Exception('test')

    base = 1
", "test.py");
            assertEq(2, pp.callMethod("test", "test", 1));
            assertEq(1, pp.callMethod("int", "bit_length", 1));

            assertThrows("NO-METHOD", \pp.callMethod(), ("test", "xxx"));
            assertThrows("NameError", \pp.callMethod(), ("test", "normal", NOTHING, 1));
            assertThrows("NO-METHOD", \pp.callMethod(), ("test", "__name__"));
            assertThrows("Exception", \pp.callMethod(), ("test", "do_ex"));
            assertThrows("NameError", \pp.evalExpression(), "test()");
        }

        {
            PythonProgram pp("
class test:
    \"\"\"test docs\"\"\"

    @staticmethod
    def get():
        return test()

    @staticmethod
    def dostatic():
        return 1

    def doit(self):
        return 1

    def doerr():
        return 1

    def other(self):
        return self.num

    def editdoc(self):
        self.__doc__ = 1

    def edittype(self):
        t = type(self)
        t.__basicsize__ = 2

    def gettype(self):
        return type(self)

    def getattr(self, attr):
        return getattr(self, attr)

    def delclassattr(self, attr):
        delattr(self.__class__, attr)

    def delparentclassattr(self, attr):
        delattr(self.__class__.__bases__[0], attr)

    def delattr(self, attr):
        delattr(self, attr)

    num = 1", "test.py");

            object x = pp.callMethod("test", "get");
            assertEq(Type::Int, x.__sizeof__().type());
            assertEq(1, x.dostatic());
            assertEq(1, x.doit());
            assertEq(1, x.other());
            assertThrows("TypeError", \x.doerr());
            assertRegex("^<test.py.test object", x.__repr__());
            assertThrows("TypeError", \x.__new__());
            assertEq(Type::List, x.__reduce__().type());
            assertEq(Type::Object, x.__subclasshook__().type());
            assertEq(Type::List, x.__dir__().type());
            assertEq("test docs", x.__doc__);
            x.editdoc();
            assertEq(1, x.__doc__);
            assertThrows("AttributeError", \x.edittype());
            assertEq(Type::Int, x.gettype().__basicsize__.type());
            assertEq(1, x.getattr("num"));
            x.delclassattr("dostatic");
            assertEq(1, x.dostatic());
            x.delclassattr("doit");
            assertEq(1, x.doit());
            assertThrows("TypeError", \x.delparentclassattr(), "__repr__");
            assertRegex("^<test.py.test object", x.__repr__());
            assertThrows("TypeError", \x.delparentclassattr(), "__sizeof__");
            assertEq(Type::Int, x.__sizeof__().type());
            assertThrows("TypeError", \x.delparentclassattr(), "__subclasshook__");
            assertEq(Type::Object, x.__subclasshook__().type());
            assertThrows("TypeError", \x.delparentclassattr(), "__new__");
            assertThrows("TypeError", \x.__new__());

            delete pp;
            assertThrows("PYTHON-ERROR", \x.dostatic());
        }
    }

    importTest() {
        {
            Program p(PO_NEW_STYLE);
            p.parse("
%module-cmd(python) import math.sin

auto sub get(auto arg) {
    return math::sin(arg);
}", "import.q");

            assertFloatEq(0.841470985, p.callFunction("get", 1), 0.000000001);
            assertFloatEq(0.841470985, p.callFunction("math::sin", 1), 0.000000001);
            assertThrows("NO-FUNCTION", \p.callFunction(), ("math::cos", 1));
        }

        {
            Program p(PO_NEW_STYLE);
            p.parse("
%module-cmd(python) import math

auto sub get(auto arg) {
    return math::sin(arg);
}", "import.q");

            assertEq("math", p.getExpression("math::__name__", "test").eval());
            assertEq(Type::String, p.getExpression("__doc__", "test").eval().type());
            assertEq(Type::String, p.getExpression("__package__", "test").eval().type());
            #__file__ not present in staticly-linked C modules
            #assertEq(Type::String, p.getExpression("__file__", "test").eval().type());
            assertFloatEq(0.841470985, p.callFunction("get", 1), 0.000000001);
            assertFloatEq(0.841470985, p.callFunction("math::sin", 1), 0.000000001);
            assertFloatEq(0.540302306, p.callFunction("math::cos", 1), 0.000000001);
            assertEq(M_PI, p.getExpression("pi", "test").eval());
        }

        {
            Program p(PO_NEW_STYLE);
            p.parse("
%module-cmd(python) import json.JSONEncoder

auto sub get() {
    return new JSONEncoder();
}", "import.q");

            assertEq(Type::Object, p.callFunction("get").type());
            object o = p.callFunction("get");
%ifndef NO_JSON
            assertEq({"a": 1}, parse_json(o.encode({"a": 1})));
%endif
        }

        {
            Program p(PO_NEW_STYLE);
            p.parse("
%module-cmd(python) import json

auto sub get() {
    return new JSONEncoder();
}", "import.q");

            assertEq(Type::Object, p.callFunction("get").type());
            object o = p.callFunction("get");
%ifndef NO_JSON
            assertEq({"a": 1}, parse_json(o.encode({"a": 1})));
%endif
        }
    }
}

public namespace Test {
    sub ex1() {
        throw 1;
    }

    sub ex2() {
        throw "TEST", "test";
    }

    string sub get() {
        return "55.00 €";
    }

    class Test {
        int get() {
            return 1;
        }
    }

    public class AbstractTest {
        abstract int get();

        int addOneNormal(int x) {
            return x + 1;
        }

        static int addOne(int x) {
            return x + 1;
        }
    }

    public namespace X {
        public class T;
    }

    class TestClass {
        public {
            int i;
        }

        constructor(int i) {
            self.i = i;
        }

        int get() {
            return i;
        }
    }
}

public int sub test() {
    return 99;
}