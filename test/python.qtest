#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%require-types
%strict-args
%enable-all-warnings

%requires python
%requires QUnit

%exec-class PythonTest

class PythonTest inherits Test {
    public {
    }

    constructor() : Test("python test", "1.0") {
        addTestCase("basic test", \basicTest());
        # Set return value for compatibility with test harnesses that check the return value
        set_return_value(main());
    }

    basicTest() {
        assertEq(2, PythonProgram::evalExpression("1 + 1"));
        assertEq(1.1, PythonProgram::evalExpression("1.1"));
        assertTrue(PythonProgram::evalExpression("True"));
        assertFalse(PythonProgram::evalExpression("False"));
        assertEq(<abcd>, PythonProgram::evalExpression("bytes.fromhex('abcd')"));
        assertEq(<abcd>, PythonProgram::evalExpression("bytearray.fromhex('abcd')"));
        assertEq({"a": 1}, PythonProgram::evalExpression("{'a': 1}"));
        assertEq(1, PythonProgram::evalExpression("(1).bit_length()"));

        {
            PythonProgram pp("def test():\n    return 1", "test.py");
            assertEq(1, pp.callFunction("test"));
            assertThrows("NO-FUNCTION", \pp.callFunction(), "xxx");
            # test module dictionary key that exists but is not a function
            assertThrows("NO-FUNCTION", \pp.callFunction(), "__name__");
        }

        {
            PythonProgram pp("def test(val):\n    return val + 1", "test.py");
            assertEq(2, pp.callFunction("test", 1));
        }

        # test parse error handling
        assertThrows("SyntaxError", "invalid syntax",
            sub () { PythonProgram pp("def test(int val):\n    return val + 1", "test.py"); });

        {
            PythonProgram pp("def test(val):\n    return val + 1", "test.py");
            assertThrows("TypeError", \pp.callFunction(), ("test", 1, 2));
        }

        {
            PythonProgram pp("def test():\n    raise Exception('err', 'desc')", "test.py");
            assertThrows("Exception", \pp.callFunction(), "test");
        }

        {
            PythonProgram pp("import datetime\ndef test():\n    return datetime.datetime.now()", "test.py");
            auto val = pp.callFunction("test");
            auto control = now_us();
            assertEq(Type::Date, val.type());
            assertLt(1m, control - val);
        }

        {
            PythonProgram pp("def test(dict, key):\n    return dict.get(key)", "test.py");
            assertEq(1, pp.callFunction("test", {"a": 1}, "a"));
            date dt = now_us();
            assertEq(dt, pp.callFunction("test", {"a": dt}, "a"));
            dt = 2s;
            assertEq(dt, pp.callFunction("test", {"a": dt}, "a"));
            binary b = <abcd>;
            assertEq(b, pp.callFunction("test", {"a": b}, "a"));
            list<auto> l = (1, "two", 3.0);
            assertEq(l, pp.callFunction("test", {"a": l}, "a"));
            assertEq(1.1, pp.callFunction("test", {"a": 1.1}, "a"));
        }

        {
            PythonProgram pp("import datetime\ndef test():\n    return datetime.datetime.now(datetime.timezone(datetime.timedelta(hours=1)))", "test.py");
            auto val = pp.callFunction("test");
            auto control = now_us();
            assertEq(Type::Date, val.type());
            assertLt(1m, control - val);
            assertEq(3600, val.info().utc_secs_east);
        }

        {
            PythonProgram pp("class test:
    def normal(self, val):
        return val + base

    @staticmethod
    def test(val):
        return val + test.base

    base = 1
", "test.py");
            assertEq(2, pp.callMethod("test", "test", 1));
            assertEq(1, pp.callMethod("int", "bit_length", 1));

            assertThrows("NO-METHOD", \pp.callMethod(), ("test", "xxx"));
            assertThrows("NameError", \pp.callMethod(), ("test", "normal", NOTHING, 1));
            assertThrows("NO-METHOD", \pp.callMethod(), ("test", "__name__"));
        }
    }
}